<?php

/**
 * Implements hook_init().
 */
function myhaccp_init() {
  // Declare all of the step forms.
  $files = _get_all_steps();
  foreach ($files as $file => $type) {
    ctools_include($file, 'myhaccp', "mforms/$type/$file");
  }
}

/**
 * Implements hook_menu().
 */
function myhaccp_menu() {
  $items['prototype'] = array(
    'title' => 'MyHACCP Web Tool',
    'page callback' => 'myhaccp_list',
    'page arguments' => array(),
    'access callback' => 'myhaccp_access',
    'access arguments' => array(1),
    'file' => 'myhaccp.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['prototype/form'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('myhaccp_start_form'),
    'access callback' => 'myhaccp_access',
    'access arguments' => array(1),
    'file' => 'myhaccp.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['prototype/form/create'] = array(
    'page callback' => 'myhaccp_create',
    'access callback' => 'myhaccp_access',
    'access arguments' => array('create'),
    'file' => 'myhaccp.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['prototype/form/%/preview'] = array(
    'page callback' => 'myhaccp_preview',
    'access callback' => 'myhaccp_access',
    'access arguments' => array('view'),
    'file' => 'myhaccp.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['help/%ctools_js/%'] = array(
    'title' => 'Help',
    'page arguments' => array(1, 2),
    'page callback' => 'myhaccp_help_modal',
    'access callback' => TRUE,
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_permission().
 *
 * Define our permissions for managing the forms.
 */
function myhaccp_permission() {
  return array(
    'create myhaccp forms' => array(
      'title' => t('Create myhaccp forms'),
      'description' => t('Allow this role to create new myhaccp forms.'),
    ),
    'edit own myhaccp forms' => array(
      'title' => t('Edit own myhaccp forms'),
      'description' => t('Edit a user\'s own myhaccp forms.'),
    ),
    'edit any myhaccp forms' => array(
      'title' => t('Edit any myhaccp forms'),
      'description' => t('Edit any user\'s myhaccp forms.'),
    ),
  );
}

/**
 * Menu access callback.
 *
 * @param string $op
 *   Operation to check against.
 *
 * @return bool
 *   Boolean determining access.
 */
function myhaccp_access($op) {
  if ($op == 'create') {
    return user_access('create myhaccp forms');
  }
  else {
    return user_access('edit any myhaccp forms') && user_access('edit own myhaccp forms');
  }
}

/**
 * Implements hook_STORE_KEY_mforms_init().
 */
function myhaccp_myhaccp_mforms_init() {
  $store = MformsDatabaseStore::getInstance('myhaccp');
  $steps = MformsSteps::getInstance($store);

  // If using mustistep controls you need to explicitly define form steps and
  // its attributes.
  $controls = MyHACCPMultiStepControls::getInstance($store, $steps, array(
    'preparatory_a' => array(
      'stage' => 'preparatory',
      'value' => 'A',
      'weight' => 1,
    ),
    'preparatory_b' => array(
      'stage' => 'preparatory',
      'value' => 'B',
      'weight' => 2,
    ),
    'preparatory_c_question_1_3' => array(
      'stage' => 'preparatory',
      'value' => 'C.1',
      'weight' => 3,
    ),
    'preparatory_c_question_4' => array(
      'stage' => 'preparatory',
      'value' => 'C.2',
      'weight' => 4,
    ),
    'preparatory_d' => array(
      'stage' => 'preparatory',
      'value' => 'D',
      'weight' => 5,
    ),
    'preparatory_e' => array(
      'stage' => 'preparatory',
      'value' => 'E',
      'weight' => 6,
    ),
    'preparatory_f' => array(
      'stage' => 'preparatory',
      'value' => 'F',
      'weight' => 7,
    ),
    'preparatory_g' => array(
      'stage' => 'preparatory',
      'value' => 'G',
      'weight' => 8,
    ),
    'preparatory_h' => array(
      'stage' => 'preparatory',
      'value' => 'H',
      'weight' => 9,
    ),
    'principle_1_question_1' => array(
      'stage' => 'principles',
      'value' => '1.1',
      'weight' => 11,
    ),
    'principle_1_question_2' => array(
      'stage' => 'principles',
      'value' => '1.2',
      'weight' => 12,
    ),
    'principle_1_question_3' => array(
      'stage' => 'principles',
      'value' => '1.3',
      'weight' => 13,
    ),
    'principle_2_question_1_3' => array(
      'stage' => 'principles',
      'value' => '2.1',
      'weight' => 14,
    ),
    'principle_2_question_4' => array(
      'stage' => 'principles',
      'value' => '2.2',
      'weight' => 15,
    ),
    'principle_3' => array(
      'stage' => 'principles',
      'value' => '3',
      'weight' => 16,
    ),
    'principle_4' => array(
      'stage' => 'principles',
      'value' => '4',
      'weight' => 17,
    ),
    'principle_5' => array(
      'stage' => 'principles',
      'value' => '5',
      'weight' => 18,
    ),
    'principle_6' => array(
      'stage' => 'principles',
      'value' => '6',
      'weight' => 19,
    ),
    'principle_7' => array(
      'stage' => 'principles',
      'value' => '7',
      'weight' => 20,
    ),
  ));

  // Add the parsley.js library.
  $path = libraries_get_path('parsleyjs');
  drupal_add_js($path . '/parsley.js');
  drupal_add_js($path . '/parsley.extend.js');
  drupal_add_js(drupal_get_path('module', 'myhaccp') . '/mforms/js/parsley_custom.js');
  $path = libraries_get_path('qtip2');
  if ($path) {
    drupal_add_js($path . '/jquery.qtip.js');
    drupal_add_css($path . '/jquery.qtip.min.css');
    drupal_add_js(drupal_get_path('module', 'myhaccp') . '/mforms/js/qtip2_custom.js');
  }

  // Init the mforms.
  mforms_init_module('myhaccp', 'myhaccp', $store, $controls);
}

/**
 * Menu callback which displays the form.
 */
function myhaccp_start_form($form, &$form_state, $iid = FALSE) {
  // If we've been passed an IID then set the session to that.
  if ($iid && is_numeric($iid)) {
    // Check that this user has permission to look at this form.
    global $user;
    $select = db_select('mforms_storage', 's')
      ->fields('s', array('uid'))
      ->condition('s.iid', $iid);
    $uid = $select->execute()->fetchField();
    if (user_access('edit any myhaccp form') || $user->uid == $uid) {
      $_SESSION['iid'] = $iid;
    }
    else {
      drupal_set_message('You do not have permission to edit this user\'s form', 'error');
      drupal_access_denied();
    }
  }
  else {
    // If there is no current session open then create a new db row.
    drupal_set_message('Please edit an existing form or create a new one.');
    drupal_goto('prototype');
  }
  return mforms_build('myhaccp', 'preparatory_a', $form_state);
}

/**
 * Implements hook_theme().
 */
function myhaccp_theme($existing, $type, $theme, $path) {
  $path = drupal_get_path('module', 'myhaccp');
  $hooks = array(
    'myhacpp_p1q2_table' => array(
      'render element' => 'element',
      'path' => $path . '/theme',
      'file' => 'myhaccp.theme.inc',
      'function' => 'theme_myhacpp_p1q2_table',
    ),
    'myhacpp_p1q3_table' => array(
      'render element' => 'element',
      'path' => $path . '/theme',
      'file' => 'myhaccp.theme.inc',
      'function' => 'theme_myhacpp_p1q3_table',
    ),
    'myhacpp_p2q4_table' => array(
      'render element' => 'element',
      'path' => $path . '/theme',
      'file' => 'myhaccp.theme.inc',
      'function' => 'theme_myhacpp_p2q4_table',
    ),
  );
  $all = _get_all_steps();
  foreach ($all as $stage => $subtype) {
    // Now the hook. We want to pass in the form_state data so have added the
    // data variable. This will get properly sorted by a preprocess function so
    // the template has the correct data to display.
    $hooks[$stage] = array(
      'variables' => array('data' => NULL),
      'file' => "$stage.theme.inc",
      'path' => "$path/mforms/$subtype/$stage",
      'template' => $stage
    );
  }
  return $hooks;
}

/**
 * Returns html to display a help tip icon.
 *
 * Currently just a simple bit of html, but this function may expand to
 * to take parameters.
 *
 * @param string $link
 *   The node ID or a string like node/23.
 *
 * @return string
 *   Prepared HTML for the link tip.
 */
function _help_tip($link = '#') {
  $parts = array();
  if (is_numeric($link)) {
    $parts[0] = 'node/' . $link;
  }
  else {
    $parts = explode('#', $link);
  }

  $options = array(
    'attributes' => array(
      'class' => array(
        'help-tip',
      ),
      'title' => 'Link through to further guidance on this subject.',
      'target' => '_blank',
    ),
  );

  if (isset($parts[1])) {
    $options['fragment'] = $parts[1];
  }

  return l(t('?'), $parts[0], $options);
}

/**
 * Defines all the function names of the stages.
 *
 * @return array
 *   an array keyed by the function name with the value being the preparatory or
 *   principle stage.
 */
function _get_all_steps() {
  $files = array(
    'preparatory_a' => 'preparatory',
    'preparatory_b' => 'preparatory',
    'preparatory_c_1' => 'preparatory',
    'preparatory_c_2' => 'preparatory',
    'preparatory_d' => 'preparatory',
    'preparatory_e' => 'preparatory',
    'preparatory_f' => 'preparatory',
    'preparatory_g' => 'preparatory',
    'preparatory_h' => 'preparatory',
    'principle_1_1' => 'principle',
    'principle_1_2' => 'principle',
    'principle_1_3' => 'principle',
    'principle_2_1' => 'principle',
    'principle_2_2' => 'principle',
    'principle_3' => 'principle',
    'principle_4' => 'principle',
    'principle_5' => 'principle',
    'principle_6' => 'principle',
    'principle_7' => 'principle',
  );
  return $files;
}

/**
 * Gets all the stage functions.
 *
 * @return array
 *   Returns the array keys relating to the step names.
 */
function _get_all_step_names() {
  return array_keys(_get_all_steps());
}

/**
 * Implements hook_element_info_alter().
 */
function myhaccp_element_info_alter(&$types) {
  foreach ($types as $type => $values) {
    $types[$type]['#process'][] = 'myhaccp_process';
  }
  return;
}

/**
 * Callback: Process form elements to add errors.
 *
 * Checks the form state's storage array element for a validate entry and then
 * tries to match it's key to the current form element's #name attribute. If
 * there is a match then it adds the error class to the form element and also
 * prints a message if the form has been executed. This ensures the message
 * only appears on the current stage.
 *
 * @see myhaccp_element_info_alter()
 */
function myhaccp_process($element, &$form_state) {
  if (isset($form_state['values']['validate'])) {
    $validation = reset($form_state['values']['validate']);
    // Add the error class to each of the elements.
    foreach ($validation as $target => $message) {
      $target_parts = explode('.', $target);
      if (!empty($element['#parents'])) {
        // Check that the intersection of the target and the current element's
        // parents array are the same. If they are then this is the element we
        // want to operate on.
        if (count(array_intersect($target_parts, $element['#parents'])) == count($target_parts)) {
          // Set the error attribute.
          $element['#attributes']['class']['error'] = 'error';
          if (!empty($message) && $form_state['executed'] == TRUE && $element['#type'] !== 'radio') {
            // Add the message inline.
            $element['#validation_message'] = $message;
          }
        }
      }
    }
  }
  return $element;
}

/**
 * Process function which handles validation messages and the page title.
 *
 * @param array $form
 *   The form array to modify.
 * @param array $form_state
 *   The form_state array to get the validation from.
 *
 * @return array
 *   The modified form array.
 */
function myhaccp_form_process($form, $form_state) {
  // First check for validation messages.
  if (isset($form_state['values']['validate'])) {
    // Ensure that these validations apply to this form. We ensure this
    // by making sure the key of the element below validate is used in the
    // current form array.
    $stage = key($form_state['values']['validate']);
    if (!isset($form[$stage])) {
      // The key wasn't found so return the form.
      return $form;
    }
    // The validation will be the only element under validate.
    $validation = reset($form_state['values']['validate']);
    // Provide an intro.
    $messages = array(
      'intro' => 'The following items have errors you will need to correct:',
    );

    // Add any messages that aren't associated with fields, so called 'global'
    // validation messages.
    foreach ($validation as $target => $message) {
      $element = array_get($form, $target, FALSE);
      if ($element && isset($element['#title'])) {
        $message = $element['#title'];
      }
      $messages[$target] = $message;
    }
    // If we already have validation messages then merge ours.
    if (isset($form['validation_messages']['#validation_message'])) {
      array_merge($form['validation_messages']['#validation_message'], $messages);
    }
    else {
      // Otherwise set the messages.
      $form['validation_messages']['#validation_message'] = $messages;
    }
  }

  // Get the title of the page.
  $title = drupal_get_title();
  // Add the title in as a new markup element.
  $form['title'] = array(
    '#markup' => '<h1>' . $title . '</h1>',
    '#weight' => -20,
  );
  return $form;
}

/**
 * Converts a #name to a dot notation suitable for an array_get to parse.
 *
 * @param string $name
 *   The name to convert.
 *
 * @return string
 *   The string as dot notation.
 */
function myhacpp_element_name_to_dot($name) {
  foreach (explode('[', $name) as $element_name) {
    // Chop off the ] that may exist.
    if (substr($element_name, -1) == ']') {
      $element_name = substr($element_name, 0, -1);
    }
    $parts[] = $element_name;
  }
  return implode('.', $parts);
}

/**
 * Helper to prepare the form_state and $_POST ready to save into the db.
 *
 * Used to prepare validation messages.
 *
 * @param string $target
 *   The form #name parameter to target.
 * @param string $message
 *   The message to display.
 * @param array $form_state
 *   The current form_state array.
 * @param array $options.
 *   Options array elements:
 *   'stage' => The element key of the stage. e.g. 'preparatory_a'. Used to
 *     make sure that the validation messages don't appear on the wrong stage.
 */
function myhacpp_prepare_validation($target, $message, &$form_state, $options) {
  // Convert the dot notation target to name style elements.
  $exploded = explode('.', $target);
  $name = '';
  foreach ($exploded as $key => $element) {
    $name .= $key == 0 ? $element : '[' . $element . ']';
  }
  // Add it to the form_state.
  if (isset($options['stage'])) {
    $stage = $options['stage'];
    $form_state['values']['validate'][$stage][$name] = $message;
  }
  else {
    $form_state['values']['validate'][$name] = $message;
  }
  // Add it to the $_POST to make sure in gets saved in the db.
  $_POST['validate'][$name] = $message;
}

/**
 * Helper to clear validation errors on successful pass.
 *
 * @param array $form_state
 *   The form state array.
 */
function myhaccp_clear_validation(&$form_state) {
  if (isset($form_state['values']['validate'])) {
    unset($form_state['values']['validate']);
  }
  if (isset($_POST['validate'])) {
    unset($_POST['validate']);
  }
}

/**
 * Helper to check whether any options have been chosen in checkboxes fields.
 *
 * @param array $values
 *   The values of form_state to check.
 * @param array $element
 *   The $form element to check.
 *
 * @return bool
 *   TRUE if options are not set.
 */
function _checkboxes_field_is_empty($values, $element) {
  $options = array_get($values, $element, array());
  foreach ($options as $option) {
    if ($option !== 0) {
      $option_check = TRUE;
    }
  }
  if (!isset($option_check)) {
    return TRUE;
  }
  return FALSE;
}

function _checkbox_field_is_empty($values, $element) {
  // Just use the text field function as its the same.
  return _text_field_is_empty($values, $element);
}

/**
 * Helper to check whether any options have been chosen in radios fields.
 *
 * @param array $values
 *   The values of form_state to check.
 * @param array $element
 *   The $form element to check.
 *
 * @return bool
 *   TRUE if options are not set.
 */
function _radios_field_is_empty($values, $element) {
  // Just use the text field function as its the same.
  return _text_field_is_empty($values, $element);
}

/**
 * Checks whether a specific option has not been chosen in radio fields.
 *
 * @param string $check_value
 *   The value to check for.
 * @param array $values
 *   The values of form_state to check.
 * @param array $element
 *   The $form element to check.
 *
 * @return bool
 *   FALSE if the radio option selected is equal to the check_value.
 */
function _radios_field_is_not_value($check_value, $values, $element) {
  $value = array_get($values, $element, FALSE);
  if ($value && $value == $check_value) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Checks whether a select field has nothing selected.
 *
 * @param array $values
 *   The values of form_state to check.
 * @param array $element
 *   The $form element to check.
 *
 * @return bool
 *   TRUE if the field is empty.
 */
function _select_field_is_empty($values, $element) {
  $value = array_get($values, $element, 0);
  if ($value == '0' || empty($value)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Checks whether a file field has nothing selected.
 *
 * @param array $values
 *   The values of form_state to check.
 * @param array $element
 *   The $form element to check.
 *
 * @return bool
 *   TRUE if the field is empty.
 */
function _file_field_is_empty($values, $element) {
  $value = array_get($values, $element, FALSE);
  if ($value == 0 || empty($value)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Checks whether the given element is empty of value.
 *
 * @param array $values
 *   The values of form_state to check.
 * @param array $element
 *   The $form element to check.
 *
 * @return bool
 *   TRUE if the field is empty.
 */
function _text_field_is_empty($values, $element) {
  $value = array_get($values, $element, FALSE);
  if ($value) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Get an item from an array using "dot" notation.
 *
 * @param array $array
 *   The array to check.
 * @param string $key
 *   The name of the key. Uses dot notation to delimit the keys.
 * @param mixed $default
 *   The default value to return if not found.
 *
 * @return mixed
 *   The value if found or the default if not. If no default then returns the
 *   array.
 */
function array_get($array, $key, $default = NULL) {
  if (is_null($key)) {
    return $array;
  }

  if (isset($array[$key])) {
    return $array[$key];
  }

  foreach (explode('.', $key) as $segment) {
    if (!is_array($array) || !array_key_exists($segment, $array)) {
      return value($default);
    }

    $array = $array[$segment];
  }

  return $array;
}

/**
 * Return the default value of the given value.
 *
 * @param mixed $value
 *   The default to return.
 *
 * @return mixed
 *   The return value.
 */
function value($value) {
  return $value instanceof Closure ? $value() : $value;
}

/**
 * Returns the prepared data from the database or form_state.
 *
 * Also updates the validation values in the form_state from the database.
 *
 * @param array $data
 *   The data as returned by mforms_get_vals().
 * @param array $form_state
 *   The current form_state array. Passed by reference so that the validate
 *   values can be added.
 *
 * @return array
 *   The saved or current values of the fields.
 */
function myhaccp_prepare_values($data, &$form_state) {
  $values = array();
  if (!empty($data)) {
    $values = $data;
    if (isset($data['validate'])) {
      $form_state['values']['validate'] = $data['validate'];
    }
  }
  elseif (isset($form_state['values'])) {
    $values = $form_state['values'];
  }
  return $values;
}

/**
 * Callback to check validation for a field.
 *
 * @param string $callback
 *   Validation callback function name.
 * @param string $target
 *   Dot notation string relating to the depth of the array element to target.
 * @param array $form
 *   The form.
 * @param array $form_state
 *   The form state containing the values.
 * @param array $options
 *   An array of possible options:
 *   'check_only' boolean - determines whether to just use this function to
 *     check validation but not add any error messages to the form.
 *
 *
 * @return bool
 *   Boolean determining whether the form has failed validation.
 */
function _check_validation($callback, $target, $form, &$form_state, $options = array()) {
  $invalid = $callback($form_state['values'], $target);
  // Its possible we only want to check a field and return the invalid boolean,
  // in which case ignore the next part.
  $check_only = isset($options['check_only']) ? $options['check_only'] : FALSE;
  if (!$check_only && $invalid) {
    // Get the message from the attributes of the element.
    $message = array_get($form, $target . '.#attributes.data-parsley-error-message', NULL);
    // Prepare the validation message.
    myhacpp_prepare_validation($target, $message, $form_state, $options);
  }
  return $invalid;
}

/**
 * Validation handler that shows a successful save message.
 *
 * @see myhaccp_form_myhaccp_start_form_alter()
 */
function myhaccp_saved_message($form, &$form_state) {
  if (isset($form_state['clicked_button']) && $form_state['clicked_button']['#value'] == 'Save') {
    drupal_set_message('Study saved', 'status', FALSE);
  }
}

/**
 * The modal dialog for the help pages menu callback.
 *
 * Renders the node and passes it back in a ctools modal.
 *
 * @param bool|string $js
 *   CTools indication of js enabled.
 * @param bool|int $nid
 *   The node ID of the help node to show in the modal.
 *
 * @return string
 *   The contents of the node, that will fill the modal window.
 */
function myhaccp_help_modal($js = FALSE, $nid = FALSE) {
  if (!$nid) {
    // If no nid was provided then just forward to the help/guidance page.
    drupal_goto('help/guidance');
  }
  if ($js) {
    // Required includes for ctools to work:
    ctools_include('modal');
    ctools_include('ajax');
    // Load the node object.
    $node = node_load($nid);
    if ($node) {
      // Render the contents.
      $contents = render(node_view($node, 'full'));
      // Return the modal with node title and rendered contents.
      return ctools_modal_render($node->title, $contents);
    }
  }

  // We don't have js so forward on to the help node.
  drupal_goto('node/' . $nid);
}

/**
 * Prepares an ajax enabled modal link for help text.
 *
 * @param int $nid
 *   The node ID to link to.
 *
 * @return string
 *   The rendered link.
 */
function myhaccp_prepare_more_link($nid) {
  // Add the ajax library.
  drupal_add_library('system', 'drupal.ajax');
  // Prepare the options.
  $options = array(
    'html' => TRUE,
    'attributes' => array(
      'class' => array(
        'use-ajax',
        'ctools-modal-myhaccp-style',
        'more-link',
      ),
      'title' => 'Link through to further guidance on this subject.',
      'target' => '_blank',
    ),
  );
  $destination = 'help/nojs/' . $nid;

  // Return the link.
  return l(t('More information &raquo;'), $destination, $options);
}

/**
 * Checks to make sure hazard data exists.
 *
 * This is used by principle steps to check that previous steps have been filled
 * in correctly, or at least enough to progress to a stage in the form.
 *
 * @return int
 *   Return an instance count.
 */
function myhaccp_ensure_hazards_exist() {
  $data = mforms_get_vals('myhaccp', 'principle_1_question_1');
  $instance_count = 0;
  if (isset($data)) {
    foreach ($data['principle_1_question_1'] as $key => $instance) {
      if (strpos($key, 'instance') === 0) {
        if (array_get($instance, 'wrapper.step_no', FALSE) && array_get($instance, 'wrapper.step_name', FALSE)) {
          $checks = array(
            "hazards_wrapper.biological" => '_text_field_is_empty',
            "hazards_wrapper.physical" => '_text_field_is_empty',
            "hazards_wrapper.allergens" => '_text_field_is_empty',
            "hazards_wrapper.chemical" => '_text_field_is_empty',
          );

          // Check that the hazard fields have been filled in.
          foreach ($checks as $target => $callback) {
            $invalid[] = $callback($instance, $target);
          }

          // If all four hazard fields from the previous stage are 'invalid'
          // (empty) then this instance doesn't pass.
          if (in_array(FALSE, $invalid)) {
            // Increment the instance count.
            $instance_count++;
          }

        }
      }
    }
  }
  return $instance_count;
}


/**
 * Gets all hazards over the specified threshold in principle 1 question 2.
 *
 * @return array
 *   An array of each item's data.
 */
function myhaccp_get_items_over_threshold() {
  $items = array();
  $data = mforms_get_vals('myhaccp', 'principle_1_question_2');
  $threshold = array_get($data, 'principle_1_question_2.threshold', FALSE);
  // Iterate through the previous data and look for instances which have the
  // correct form fields filled out.
  if (isset($data) && $threshold) {
    foreach ($data['principle_1_question_2'] as $key => $instance) {
      if (strpos($key, 'instance') === 0) {
        foreach ($instance['instance_table'] as $key => $item) {
          if (isset($item['significance']) && $item['significance'] >= $threshold) {
            $items[] = $item;
          }
        }
      }
    }
  }
  return $items;
}

/**
 * Ensure there are hazards over the set threshold in principle 1 question 2.
 *
 * @return int
 *   The count of hazards over the threshold.
 */
function myhaccp_ensure_over_threshold() {
  $items = myhaccp_get_items_over_threshold();
  return count($items);
}

/**
 * Gets all hazards which are a CCP.
 *
 * @return array
 *   Returns all CCP items.
 */
function myhaccp_get_ccps() {
  $items = array();
  $data = mforms_get_vals('myhaccp', 'principle_2_question_4');
  $rows = array_get($data, 'principle_2_question_4.instance_table', array());
  // Iterate through the previous data.
  foreach ($rows as $key => $item) {
    if (is_array($item)) {
      $hazard = unserialize($item['hazard']);
      // Determine the critical control point.
      if (!empty($item['ccp']) && $item['ccp'] == 'yes') {
        $items[] = $hazard;
      }
    }
  }
  return $items;
}

/**
 * Returns the CCP count.
 *
 * @return int
 *   The count of ccp items found.
 */
function myhaccp_ensure_ccps_exist() {
  $items = myhaccp_get_ccps();
  return count($items);
}

/**
 * Check that there is data in one or more fields.
 *
 * @param array $form_state
 *   The form_state array containing the values.
 * @param string $validation_name
 *   The name of the calling function using the magic constant.
 *
 * @return bool
 *   Boolean indicating whether any field values were found. TRUE if none were
 *   found, FALSE if there were one or more values.
 */
function myhacpp_all_fields_are_empty($form_state, $validation_name) {
  // Get the stage name from the passed validation function name.
  $stage = str_replace('_validate', '', $validation_name);
  // Iterate over all the form_state values.
  $iterator = new RecursiveArrayIterator($form_state['values'][$stage]);
  // Prepare a new standard class so we can pass through items found from the
  // iterator.
  $found = new stdClass;
  $found->items = array();
  // Apply an iterator callback to each element of the array.
  iterator_apply($iterator, 'myhaccp_find_values', array($iterator, $found));
  // Check if there are any found items.
  if (!empty($found->items)) {
    // We have one of more values so return FALSE.
    return FALSE;
  }
  // Nothing found so return TRUE.
  return TRUE;
}

/**
 * Iterator function to traverse the fields.
 *
 * @param RecursiveArrayIterator $iterator
 *   An instance of the iterator object.
 * @param object $found
 *   A object (passed by reference by default) that contains an items element
 *   which is used to populate keys of any fields with a value. This is then
 *   used in the calling function to determine whether values have been found.
 */
function myhaccp_find_values($iterator, $found) {
  while ($iterator->valid()) {
    // Check if there are children.
    if ($iterator->hasChildren()) {
      // Call this function again to iterate over the children.
      myhaccp_find_values($iterator->getChildren(), $found);
    }
    else {
      $key = $iterator->key();
      $value = $iterator->current();
      // Check if this value is not empty.
      if (!empty($value)) {
        // Add the key as an item to the found items array to be counted later.
        $found->items[] = $key;
      }
    }
    // Move on to the next element.
    $iterator->next();
  }
}
